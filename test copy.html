<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>Multi Globe Patterns</title>
    <!-- Include three.js library -->
    <script src='js/three.js'></script>
    <!-- Include OBJLoader and MTLLoader -->
    <script src='js/OBJLoader.js'></script>
    <script src='js/MTLLoader.js'></script>
    <!-- Include jsartookit -->
    <script src="jsartoolkit5/artoolkit.min.js"></script>
    <script src="jsartoolkit5/artoolkit.api.js"></script>
    <!-- Include threex.artoolkit -->
    <script src="threex/threex-artoolkitsource.js"></script>
    <script src="threex/threex-artoolkitcontext.js"></script>
    <script src="threex/threex-arbasecontrols.js"></script>
    <script src="threex/threex-armarkercontrols.js"></script>

    <style>
        #overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.5); /* Semi-transparent white */
            padding: 10px;
            border-radius: 5px;
        }
        .marker-status {
            color: black;
            font-size: 14px;
        }
        .found {
            color: green;
        }
        .not-found {
            color: red;
        }
        #completion-popup {
            display: none;
            position: fixed;
            width: 80%;
            height: 60%;
            top: 10%;
            left: 10%;
            background-color: white;
            border: 2px solid #000;
            border-radius: 10px;
            z-index: 100;
            text-align: center;
            padding: 20px;
        }
        #model-container {
            width: 100%;
            height: 80%;
            position: relative;
        }
    </style>
</head>

<body style='margin : 0px; overflow: hidden; font-family: Monospace;'>

<div id="overlay">
    <div id="statusLetterA" class="marker-status">Letter A: <span class="not-found">✗</span></div>
    <div id="statusLetterB" class="marker-status">Letter B: <span class="not-found">✗</span></div>
    <div id="statusLetterC" class="marker-status">Letter C: <span class="not-found">✗</span></div>
    <div id="statusLetterD" class="marker-status">Letter D: <span class="not-found">✗</span></div>
    <div id="statusLetterE" class="marker-status">Letter E: <span class="not-found">✗</span></div>
    <div id="statusLetterF" class="marker-status">Letter F: <span class="not-found">✗</span></div>
    <div id="statusLetterG" class="marker-status">Letter G: <span class="not-found">✗</span></div>
</div>

<div id="completion-popup">
    <h2>Congratulations! You've found all the markers!</h2>
    <div id="model-container"></div>
    <button onclick="hideCompletionPopup()">Close</button>
    <button onclick="window.location.reload()">Play Again</button>
</div>

<script>
    var scene, camera, renderer, clock, deltaTime, totalTime;

    var arToolkitSource, arToolkitContext;
    var markerRoots = [];
    var meshes = [];

    initialize();
    animate();

    function initialize() {
        scene = new THREE.Scene();

        let ambientLight = new THREE.AmbientLight(0xcccccc, 0.5);
        scene.add(ambientLight);

        camera = new THREE.Camera();
        scene.add(camera);

        renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
        });
        renderer.setClearColor(new THREE.Color('lightgrey'), 0);
        renderer.setSize(640, 480);
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = '0px';
        renderer.domElement.style.left = '0px';
        document.body.appendChild(renderer.domElement);

        clock = new THREE.Clock();
        deltaTime = 0;
        totalTime = 0;

        // Setup AR toolkit source
        arToolkitSource = new THREEx.ArToolkitSource({
            sourceType: 'webcam',
        });

        function onResize() {
            arToolkitSource.onResize();
            arToolkitSource.copySizeTo(renderer.domElement);
            if (arToolkitContext.arController !== null) {
                arToolkitSource.copySizeTo(arToolkitContext.arController.canvas);
            }
        }

        arToolkitSource.init(function onReady() {
            onResize();
        });

        window.addEventListener('resize', function() {
            onResize();
        });

        // Setup AR toolkit context
        arToolkitContext = new THREEx.ArToolkitContext({
            cameraParametersUrl: 'data/camera_para.dat',
            detectionMode: 'mono'
        });

        arToolkitContext.init(function onCompleted() {
            camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
        });

        // Define your markers
        let patternArray = ["LetterA", "LetterB", "LetterC", "LetterD", "LetterE", "LetterF", "LetterG"];

        // Create markers
        patternArray.forEach(function(pattern) {
            let markerRoot = new THREE.Group();
            scene.add(markerRoot);
            let markerControls = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
                type: 'pattern', patternUrl: "data/" + pattern + ".patt",
            });

            // Create a visual object for each marker
            let geometry = new THREE.SphereGeometry(1, 32, 32);
            let loader = new THREE.TextureLoader();
            let texture = loader.load('images/' + pattern + '.jpg');
            let material = new THREE.MeshLambertMaterial({ map: texture, opacity: .8 });
            let mesh = new THREE.Mesh(geometry, material);
            mesh.position.y = 1;
            markerRoot.add(mesh);
            markerRoots.push(markerRoot);
            meshes.push(mesh);
        });
    }

    function update() {
        let allMarkersFound = true;
        markerRoots.forEach(function(markerRoot, index) {
            if (markerRoot.visible) {
                meshes[index].rotation.y += 0.01;
                document.getElementById('status' + patternArray[index]).getElementsByClassName('not-found')[0].className = 'found';
                document.getElementById('status' + patternArray[index]).getElementsByClassName('found')[0].innerText = '✓';
            } else {
                allMarkersFound = false;
            }
        });

        if (allMarkersFound) {
            showCompletionPopup();
        }

        if (arToolkitSource.ready !== false) {
            arToolkitContext.update(arToolkitSource.domElement);
        }
    }

    function render() {
        renderer.render(scene, camera);
    }

    function animate() {
        requestAnimationFrame(animate);
        deltaTime = clock.getDelta();
        totalTime += deltaTime;
        update();
        render();
    }

    // Function to show completion popup and load the model
    function showCompletionPopup() {
        document.getElementById('completion-popup').style.display = 'block';
        loadModel();
    }

    // Function to hide the popup
    function hideCompletionPopup() {
        document.getElementById('completion-popup').style.display = 'none';
    }

    // Function to load the 3D model
    function loadModel() {
        new THREE.MTLLoader().load('models/fish-2.mtl', function (materials) {
            materials.preload();
            new THREE.OBJLoader()
                .setMaterials(materials)
                .load('models/fish-2.obj', function (object) {
                    object.position.set(0, 0, 0);
                    object.scale.set(0.1, 0.1, 0.1); // Scale the model down
                    object.rotation.y = Math.PI; // Rotate the model if needed
                    document.getElementById('model-container').appendChild(renderer.domElement);
                    scene.add(object);
                    animateModel(object);
                });
        });
    }

    // Function to animate the model
    function animateModel(model) {
        requestAnimationFrame(function() { animateModel(model); });
        model.rotation.y += 0.01;
        renderer.render(scene, camera);
    }

</script>




</body>
</html>
